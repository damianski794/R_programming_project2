---
title: "projekt 2"
author: "Damian Wysokiński"
date: "12 12 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(stringsAsFactors=FALSE)

library(sqldf)
library(dplyr)
library(data.table)
library(microbenchmark)
#library(R.utils)

```

Wczytanie danych
```{r}

# to data.frames
Badges <- read.csv("travel_stackexchange_com/Badges.csv.gz")
Comments <- read.csv("travel_stackexchange_com/Comments.csv.gz")
PostLinks <- read.csv("travel_stackexchange_com/PostLinks.csv.gz")
Posts <- read.csv("travel_stackexchange_com/Posts.csv.gz")
Tags <- read.csv("travel_stackexchange_com/Tags.csv.gz")
Users <- read.csv("travel_stackexchange_com/Users.csv.gz")
Votes <- read.csv("travel_stackexchange_com/Votes.csv.gz")

# to data.tables
Badges_dt <- fread("travel_stackexchange_com/Badges.csv.gz")
Comments_dt <- fread("travel_stackexchange_com/Comments.csv.gz")
PostLinks_dt <- fread("travel_stackexchange_com/PostLinks.csv.gz")
Posts_dt <- fread("travel_stackexchange_com/Posts.csv.gz")
Tags_dt <- fread("travel_stackexchange_com/Tags.csv.gz")
Users_dt <- fread("travel_stackexchange_com/Users.csv.gz")
Votes_dt <- fread("travel_stackexchange_com/Votes.csv.gz")
```

Wykonane zadania
```{r}
wersja_dyplr <- c('T','N','T','T','N')
wersja_f_bazowe <- c('T','N','T','T','N')
wersja_data_table <- c('T','N','T','T','N')
testy_szybkosci <- c('N', 'N', 'N', 'N', 'N')
intepretacje <- c('T', 'T', 'T', 'T', 'T')
head(data.frame(wersja_dyplr, wersja_f_bazowe, wersja_data_table, testy_szybkosci, intepretacje))
```

Zad1
```{r}
# SQL
zad1_sql <- sqldf('SELECT Posts.Title, RelatedTab.NumLinks
FROM
  (SELECT RelatedPostId AS PostId, COUNT(*) AS NumLinks
  FROM PostLinks
  GROUP BY RelatedPostId) AS RelatedTab
JOIN Posts ON RelatedTab.PostId=Posts.Id
WHERE Posts.PostTypeId=1
ORDER BY NumLinks DESC
')

#zad1_sql
```
Interpretacja zapytania:

1. Stwórz tabele RelatedTab jako zapytanie:
    1. Wybierz RelatedPostId z aliasem PostId, liczbe kazdej z grup RelatedPostId z aliasem NumLinks z tabeli PostLinks
2. Polacz tabele (inner joinem) z Posts
3. Przefiltruj po PostTypeId = 1
4. Wybierz Title, NumLinks
5. Uszereguj wzgledem NumLinks malejaco
  

```{r}
#zad 1 wewnetrzna wartosc

RelatedTab_zad_1_sql <- sqldf('SELECT RelatedPostId AS PostId, COUNT(*) AS NumLinks
  FROM PostLinks
  GROUP BY RelatedPostId 
')
 
#head(RelatedTab_zad_1_sql)
```
zad 1 dplyr
```{r}
# RelatedTab_zad_1_sql 
# PostLinks 

RelatedTab <- PostLinks %>%
  group_by(RelatedPostId) %>%
  summarise(NumLinks = n()) %>% 
  rename(PostId = RelatedPostId)

all_equal(RelatedTab, RelatedTab_zad_1_sql)

zad1_dplyr <- inner_join(RelatedTab,Posts, by = c("PostId" = "Id")) %>% 
  filter(PostTypeId == 1) %>% 
  select(Title, NumLinks) %>% 
  arrange(desc(NumLinks))

all_equal(zad1_dplyr, zad1_sql)
```
Zad 1 data.table
```{r}
related_table_dt <- PostLinks_dt[, .(NumLinks = .N), by = RelatedPostId] %>% setnames(old = "RelatedPostId", new = "PostId")
# related_table_dt

all_equal(RelatedTab_zad_1_sql, related_table_dt) # do tego miejsca jest tak samo
#################################
zad1_sql_bez_where <- sqldf('SELECT Posts.Title, RelatedTab.NumLinks
FROM
  (SELECT RelatedPostId AS PostId, COUNT(*) AS NumLinks
  FROM PostLinks
  GROUP BY RelatedPostId) AS RelatedTab
JOIN Posts ON RelatedTab.PostId=Posts.Id
ORDER BY NumLinks, Title')


merged <- merge(related_table_dt, Posts_dt, by.x = "PostId", by.y = "Id")
keycol <- c("NumLinks")
merged <- setorderv(merged, keycol, c(-1))
merged <- merged[PostTypeId == 1, c("Title", "NumLinks")]
merged$Title <- gsub('""','"',merged$Title) # data.table zamiast "..." tworzy ""..."" wiec trzeba zamienic podwojne "" na pojedyncze "
                                            # jest to absurdalne zachowanie data.table
all_equal(merged, zad1_sql)               
```

zad 1 funkcje bazowe
```{r}
#  RelatedTab_zad_1_bf <- aggregate(. ~ RelatedPostId, PostLinks, length)
RelatedTab_zad_1_bf <-  setNames(aggregate(PostLinks[, 'RelatedPostId'], by = list(PostId = PostLinks$RelatedPostId), length), c("PostId", "NumLinks"))

all_equal(RelatedTab_zad_1_sql, RelatedTab_zad_1_bf)

merged <- merge(RelatedTab_zad_1_bf, Posts, by.x = "PostId", by.y = "Id")
keycol <- c("NumLinks")
merged <- setorderv(merged, keycol, c(-1))
merged <- merged[merged$PostTypeId == 1, c("Title", "NumLinks")]
merged$Title <- gsub('""','"',merged$Title) # data.table zamiast "..." tworzy ""..."" wiec trzeba zamienic podwojne "" na pojedyncze "
                                            # jest to absurdalne zachowanie data.table
all_equal(merged, zad1_sql)
```

Porównanie czasowe

```{r}
x = 1:1000000
microbenchmark(sqrt(x),
               x^2)
```

Zad 2 sql
```{r}
zad2_sql <- sqldf(
'SELECT
  Users.DisplayName,
  Users.Age,
  Users.Location,
  SUM(Posts.FavoriteCount) AS FavoriteTotal,
  Posts.Title AS MostFavoriteQuestion,
  MAX(Posts.FavoriteCount) AS MostFavoriteQuestionLikes
FROM Posts
JOIN Users ON Users.Id=Posts.OwnerUserId
WHERE Posts.PostTypeId=1
GROUP BY OwnerUserId
ORDER BY FavoriteTotal DESC
LIMIT 10
')
#head(zad2_sql)
```
Interpretacja zapytania:

(To zapytanie jest w jakims dziwnym standardzie bo selectowane sa dane niewchodzace w sklad grupowania - imo blednym)

1. Polacz tabele Posts z Users
2. Przefiltruj po PostTypeId = 1
3. Pogrupuj po OwnerUserId
4. Wybierz DisplayName, Age, Location, sume FavouriteCount z aliasem FavoriteTotal, Title z aliasem MostFavoriteQuestion, max FavoriteCount z aliasem MostFavoriteQuestionLikes
5. Uszereguj po FavoriteTotal malejaco
6. Wybierz 10 pierwszych wierszy tabeli

Zad 2 dplyr
```{r}

# bledne rozwiazanie - wielokrotnie pojawia sie MostFaviouteQuestion dla nawego Favourite Count
users_inner <- Users %>% select(DisplayName, Age, Location, Id)

inner_join(Posts, Users, by = c("OwnerUserId" = "Id")) %>% 
  filter(PostTypeId == 1, !is.na(FavoriteCount)) %>% 
  group_by(OwnerUserId) %>%
  #summarise(FavoriteTotal = sum(FavoriteCount), MostFavoriteQuestionLikes = max(FavoriteCount)) %>% 
  summarise(DisplayName, Age, Location, FavoriteTotal = sum(FavoriteCount), MostFavoriteQuestion = Title, MostFavoriteQuestionLikes = max(FavoriteCount)) %>%
  #inner_join(users_inner, by = c("OwnerUserId" = "Id")) %>%
  ungroup() %>%
  select(DisplayName, Age, Location, FavoriteTotal, MostFavoriteQuestion, MostFavoriteQuestionLikes) %>% 
  arrange(desc(FavoriteTotal)) %>% 
  top_n(10)
  
  #rename(MostFavoriteQuestion = Title)

```
Zad 3

Zad3 SQL
```{r}
zad3_sql <- sqldf("
SELECT
  Posts.Title,
  CmtTotScr.CommentsTotalScore
FROM (
    SELECT
      PostID,
      UserID,
      SUM(Score) AS CommentsTotalScore
    FROM Comments
    GROUP BY PostID, UserID
) AS CmtTotScr
JOIN Posts ON Posts.ID=CmtTotScr.PostID AND Posts.OwnerUserId=CmtTotScr.UserID
WHERE Posts.PostTypeId=1
ORDER BY CmtTotScr.CommentsTotalScore DESC
LIMIT 10")

#head(zad3_sql)
```
Interpretacja zapytania:

1. Stworz tabele CmtTotScr jako:
    1. Wybierz tabele Comments
    2. Pogrupuj po PostId, UserId
    3. Wyznacz PostId, UserId, sum Score z aliasem CommentsTotalScore
2. Polacz CmtTotScr z Post
3. Przefiltruj po PostTypeId=1
4. Uszereguj po CommentsTotalScore
5. Wyznacz Title, CommentsTotalScore
6. Wybierz 10 pierwszych wierszy

zad3 dyplyr
```{r}
CmtTotScr_sql <- sqldf('SELECT
PostID,
UserID,
SUM(Score) AS CommentsTotalScore
FROM Comments
GROUP BY PostID, UserID')

CmtTotScr <- Comments %>% 
  group_by(PostId, UserId) %>% 
  summarise(CommentsTotalScore = sum(Score))

all_equal(CmtTotScr, CmtTotScr_sql)

zad3_dyplr <- inner_join(CmtTotScr, Posts, by = c("PostId"="Id", "UserId"="OwnerUserId")) %>% 
  filter(PostTypeId == 1) %>% 
  arrange(desc(CommentsTotalScore)) %>%
  ungroup() %>% 
  select(Title, CommentsTotalScore) %>% 
  top_n(10)

all_equal(zad3_dyplr, zad3_sql)
```

Zad3 data.table
```{r}
CmtTotScr_dt <- Comments_dt[, .(CommentsTotalScore = sum(Score)),.(PostId,UserId)]
all_equal(CmtTotScr_dt, CmtTotScr_sql)

merged <- merge(CmtTotScr_dt, Posts_dt, by.x = c("PostId", "UserId"), by.y = c("Id","OwnerUserId"))
merged <- merged[PostTypeId==1,]
# colnames(merged)

keycol <- c("CommentsTotalScore")
merged <- setorderv(merged, keycol, c(-1))
merged <- merged[1:10,.(Title, CommentsTotalScore)]

all_equal(zad3_sql, merged)
```
Zad3 funkcje bazowe
```{r}
#(CmtTotScr_bf <- setNames(aggregate(Comments[,c('Score')], by = list(PostId = Comments$PostId, UserId = Comments$UserId), sum), c('PostId', 'UserId', 'CommentsTotalScore')))

#pierwszy argument w aggregate:
CmtTotScr_bf <- setNames(aggregate(Comments$Score, by=list(PostID=Comments$PostId, 
                      UserID=Comments$UserId), sum), c('PostId', 'UserId', 'CommentsTotalScore'))

#all_equal(CmtTotScr_sql, CmtTotScr_bf)
merged <- merge(CmtTotScr_bf, Posts, by.x = c("PostId", "UserId"), by.y = c("Id","OwnerUserId"))
merged <- merged[merged[,"PostTypeId"] == 1, ]

keycol <- c("CommentsTotalScore")
merged <- setorderv(merged, keycol, c(-1))
merged <- merged[1:10,c("Title", "CommentsTotalScore")]

all_equal(zad3_sql, merged)

```


Zad4

zad4 sql
```{r}
zad4_sql <- sqldf('
SELECT DISTINCT
  Users.Id,
  Users.DisplayName,
  Users.Reputation,
  Users.Age,
  Users.Location
FROM (
      SELECT
        Name, UserID
      FROM Badges
      WHERE Name IN (
        SELECT
          Name
        FROM Badges
        WHERE Class=1
        GROUP BY Name
        HAVING COUNT(*) BETWEEN 2 AND 10
      )
    AND Class=1
  ) AS ValuableBadges
JOIN Users ON ValuableBadges.UserId=Users.Id
')
#head(zad4_sql)
```
Interpretacja zapytania

1. Wybierz Nazwy jako:
    1. Przefiltruj tabele Badges po Class = 1
    2. Pogrupuj po Name
    3. Wybierz grupy o licznosci od -2 do 10
    4. Zwroc Name
2. Stworz tabele ValuableBadges jako:
    1. Przefiltuj tabele Badges dla Name wchodzacych w sklad Nazw z punktu 1 oraz dla Class = 1
    2. Wybierz Name, UserId
3. Polacz ValuableBadges z Users
4. Wybierz Id, DisplayName, Reputation, Age, Location (wiersze nie moga sie powtarzac)

zad4_dyplr
```{r}
inner_names_sql <- sqldf('
SELECT
Name
FROM Badges
WHERE Class=1
GROUP BY Name
HAVING COUNT(*) BETWEEN 2 AND 10')

inner_names <- Badges %>% 
  filter(Class == 1) %>% 
  group_by(Name) %>% 
  summarise(cnt = n()) %>% 
  ungroup() %>% 
  filter(cnt >= 2, cnt <= 10) %>% 
  select(Name) %>%
    pull() #pull potrzebny do kolejnego zapytania (gdzie uzywa sie %in%s)
#all_equal(inner_names_sql, inner_names)


ValuableBadges_sql <- sqldf('
SELECT
Name, UserID
FROM Badges
WHERE Name IN (
    SELECT
      Name
    FROM Badges
    WHERE Class=1
    GROUP BY Name
    HAVING COUNT(*) BETWEEN 2 AND 10
    )
AND Class=1')

ValuableBadges <- Badges %>% 
  filter(Name %in% inner_names, Class == 1) %>% 
  select(Name, UserId)

# all_equal(ValuableBadges, ValuableBadges_sql)

zad4_dyplr <- inner_join(ValuableBadges, Users, by = c("UserId" = "Id")) %>% 
    rename(Id = UserId) %>% 
    select(Id, DisplayName, Reputation, Age, Location) %>% 
  distinct

all_equal(zad4_dyplr, zad4_sql)
```

Zad 4 data.table
```{r}
inner_names_dt <- Badges_dt[Class==1, .(count = .N), by = .(Name)]
inner_names_dt <- inner_names_dt[count >=2 & count <= 10, .(Name)]

all_equal(inner_names_sql, inner_names_dt)

ValuableBadges_dt <- Badges_dt[Class == 1 & Name %in% pull(inner_names_dt), .(Name, UserId)]

all_equal(ValuableBadges_dt, ValuableBadges_sql)

merged <- merge(ValuableBadges_dt, Users_dt, by.x = "UserId", by.y = "Id") %>% setnames(old = 'UserId', new = 'Id')
merged <- merged[, .(Id, DisplayName, Reputation, Age, Location)]
merged  <- unique(merged)
all_equal(zad4_sql, merged)
```
Zad 4 funkcje bazowe

```{r}
inner_names_bf <- Badges[Badges[,'Class']== 1,]
(Names <- aggregate(inner_names_bf[, "Name"], by = list(Name = inner_names_bf[, "Name"]), length))
(Names <- Names[Names[,'x'] >= 2 & Names[,'x'] <= 10, "Name"])

#all_equal(inner_names_sql,Names)


ValuableBadges_bf <- Badges[Badges[, 'Class'] == 1 & Badges[, 'Name']  %in% Names, ]
ValuableBadges_bf <- ValuableBadges_bf[, c("Name", "UserId")]

all_equal(ValuableBadges_sql, ValuableBadges_bf)

merged <- merge(ValuableBadges_bf, Users, by.x = "UserId", by.y = "Id") %>% setnames(old = 'UserId', new = 'Id')
merged <- merged[, c("Id", "DisplayName", "Reputation", "Age", "Location")]
merged  <- unique(merged)
all_equal(zad4_sql, merged)

```

# DO USUNIECIA:
# wywalilem Id z BestAnswers bo to sie nie kompilowalo
Zad 5

zad5_sql
```{r}
zad5_sql <- sqldf('
SELECT
    Questions.Id,
    Questions.Title,
    BestAnswers.MaxScore,
    Posts.Score AS AcceptedScore,
    BestAnswers.MaxScore-Posts.Score AS Difference
FROM (
        SELECT ParentId, MAX(Score) AS MaxScore
        FROM Posts
        WHERE PostTypeId==2
        GROUP BY ParentId
) AS BestAnswers
JOIN (
      SELECT * FROM Posts
      WHERE PostTypeId==1
    ) AS Questions
  ON Questions.Id=BestAnswers.ParentId
JOIN Posts ON Questions.AcceptedAnswerId=Posts.Id
WHERE Difference>50
ORDER BY Difference DESC
')
```
```{r}
best_answers_sql <- sqldf(
'SELECT ParentId, MAX(Score) AS MaxScore
FROM Posts
WHERE PostTypeId==2
GROUP BY ParentId')

questions_sql <- sqldf(
'SELECT * FROM Posts
WHERE PostTypeId==1'
)
zad5_pierwszy_join <- sqldf(
'SELECT
    Questions.Id,
    Questions.Title,
    BestAnswers.MaxScore
FROM (
        SELECT ParentId, MAX(Score) AS MaxScore
        FROM Posts
        WHERE PostTypeId==2
        GROUP BY ParentId
) AS BestAnswers
JOIN (
      SELECT * FROM Posts
      WHERE PostTypeId==1
    ) AS Questions
ON Questions.Id=BestAnswers.ParentId'
)
```

zad 5 dyplr
```{r}
best_answers <- Posts %>% 
  filter(PostTypeId == 2) %>% 
  group_by(ParentId) %>% 
  summarise(MaxScore = max(Score))

all_equal(best_answers_sql, best_answers)

questions <- Posts %>% 
  filter(PostTypeId == 1) %>% 
  select(everything())

all_equal(questions_sql, questions)

best_answers_questions <- inner_join(best_answers, questions, by= c("ParentId" = "Id")) %>%
  rename(Id = ParentId)

#all_equal(zad5_pierwszy_join, best_answers_questions)

best_answers_questions_posts <- inner_join(best_answers_questions, Posts, by= c("AcceptedAnswerId"="Id")) %>%
  mutate(Difference = MaxScore - Score.y) %>% 
  select(Id, Title = Title.x, MaxScore, AcceptedScore = Score.y, Difference) %>%
  filter(Difference > 50) %>% 
  arrange(desc(Difference))
all_equal(zad5_sql,best_answers_questions_posts)

```

Interpretacja zapytania:

(To zapytanie jest w jakims dziwnym standardzie bo selectowane sa dane niewchodzace w sklad grupowania - imo blednym)

1. Stworz tabele BestAnswers jako:
    1. Przefiltruj Posts po PostTypeId=2
    2. Pogrupuj po ParentId
    3. Wybierz Id, ParentId, max Score z aliasem MaxScore
2. Stworz tabele Questions jako:
    1. Przefiltruj Posts po PostTypeId = 1
    2. Wybierz wszystkie kolumny
3. Polacz BestAnswers z Questions
4. Polacz z Posts
5. Przefiltruj po Difference > 50
6. Uszereguj po Difference
7. Zwroc Id, Title, MaxScore, Score z aliasem AcceptedScore, MaxScore-Score z aliasem Difference


```{r}
Posts %>% filter(ParentId <=3) %>% select(Id, ParentId) %>% arrange(ParentId)
```



```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```
